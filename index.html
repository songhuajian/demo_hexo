<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>人总是要有追求的！加油吧！</title>
  <meta name="author" content="宋华健" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="人总是要有追求的！加油吧！" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="人总是要有追求的！加油吧！" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">人总是要有追求的！加油吧！</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-09-18T11:26:50.000Z"><a href="/2017/09/18/原型/">2017-09-18</a></time>
      
      
  
    <h1 class="title"><a href="/2017/09/18/原型/">原型</a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>1.原型需要注意的问题
</code></pre><hr>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-21T06:38:53.000Z"><a href="/2016/11/21/Sublime-text-3-部分插件/">2016-11-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/21/Sublime-text-3-部分插件/">Sublime text 3 部分插件</a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>1. autofilename
</code></pre><hr>
<pre><code>2. Alignment
</code></pre><hr>
<pre><code>3. Babel
</code></pre><hr>
<pre><code>4. HTML Beautify
</code></pre><hr>
<pre><code>5. File Header
</code></pre><hr>
<pre><code>6. Git, GitGutter
</code></pre><hr>
<pre><code>7. Sublimeserver
</code></pre><hr>
<pre><code>8.all Autocomolete
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-10-15T09:01:16.000Z"><a href="/2016/10/15/Windows下的nodejs管理工具nvm/">2016-10-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/10/15/Windows下的nodejs管理工具nvm/">Windows下的nodejs管理工具nvm</a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>1. github上下载nvm管理工具
    https://github.com/coreybutler/nvm-windows.git
    最好在nvm外加一层目录
</code></pre><hr>
<pre><code>2. 生成配置文件和环境变量
    用管理员身份打开install.cmd
    输入nvm路径
    可能需要两次
    编辑生成的settings.txt
    root: D:\develop\nvm (不用改)
    path: D:\develop\nodejs (改成nvm同级即可)
</code></pre><hr>
<pre><code>3. 修改生成的环境变量
    path: D:\develop\nodejs
    NVM_SYMLINK:D:\develop\nodejs
    NPM_HOME:D:\develop\nvm\npm
    path:%NPM_HOME%
</code></pre><hr>
<pre><code>4. 设置使用版本
    nvm list
    nvm use *.*.*
    nvm list或者node -v
</code></pre><hr>
<pre><code>5. 设置node下载和缓存
    用户文件夹下建立.npmrc
    设置
    cache=D:\develop\nvm\npm-cache
    prefix=D:\develop\nvm\npm
</code></pre><hr>
<pre><code>6. 使用npm install -g ***测试是否完成
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-10-11T04:48:22.000Z"><a href="/2016/10/11/Angular路由/">2016-10-11</a></time>
      
      
  
    <h1 class="title"><a href="/2016/10/11/Angular路由/">Angular路由</a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>1. 什么是routing（路由）
    设置页面不同于控制页面，登录页面不同于账号信息页面。
    （一个应用很多功能不同的页面）
</code></pre><hr>
<pre><code>2. 安装
    使用angular的路由功能需要安装routing模块......（引入angular-route.js就可以了）
</code></pre><hr>
<pre><code>3. 定义
    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])
    .config(function($routeProvider) {});
</code></pre><hr>
<pre><code>4. when()
    when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。
    一般main route经常使用“/”来表示，也可以定义URL参数，
    在controller里面就使用$routeParams获取url参数。
</code></pre><hr>
<pre><code>5. templateUrl: 表示路由跳转的view模板
    controller: 控制器

    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])
    .config(function($routeProvider) {
    $routeProvider
        .when(&apos;/&apos;, {
          templateUrl: &apos;views/main.html&apos;,
          controller: &apos;MainCtrl&apos;
        })
        .when(&apos;/day/:id&apos;, {
          templateUrl: &apos;views/day.html&apos;,
          controller: &apos;DayCtrl&apos;
        })
</code></pre><hr>
<pre><code>6. otherwise()
    otherwise()定义了当应用找不到指定路由的时候跳转的路由

    angular.module(&apos;myApp&apos;, [&apos;ngRoute&apos;])
    .config(function($routeProvider) {
     $routeProvider
        .when(&apos;/&apos;, {
          templateUrl: &apos;views/main.html&apos;,
          controller: &apos;MainCtrl&apos;
        })
        .when(&apos;/day/:id&apos;, {
          templateUrl: &apos;views/day.html&apos;,
          controller: &apos;DayCtrl&apos;
        })
        .otherwise({
          redirectTo: &apos;/&apos;
        });
    })
</code></pre><hr>
<pre><code>7. 使用
    定义好了路由需要怎么使用呢?
    我们要告诉angular页面的哪一个部分是我们希望转换的，
    这需要使用到ng-view指令\
    &lt;div class=&quot;header&quot;&gt;My page&lt;/div&gt;
    &lt;div ng-view&gt;&lt;/div&gt;
    &lt;span class=&quot;footer&quot;&gt;A footer&lt;/span&gt;
    这样就只有&lt;div ng-view&gt;&lt;/div&gt;会被更新， header/footer都始终保持不变
</code></pre><hr>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-10-05T08:58:40.000Z"><a href="/2016/10/05/AngularJS遇到的问题/">2016-10-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/10/05/AngularJS遇到的问题/">AngularJS遇到的问题</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="transclude"><a href="#transclude" class="headerlink" title="transclude"></a>transclude</h3><hr>
<pre><code>嵌入的意思,也就是说你是否需要将你的指令（内部）的元素嵌入到你的（模板）中去，默认为false。
如果你需要的话，那么就需要将transclude设置为true。
如果将这个值设置为true的话，就要配合angular的ng-transclude指令来进行使用，
</code></pre><hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<pre><code>1.html中的代码
&lt;!--  指令a-transclude 内部含有元素--&gt;
&lt;breadcrumb&gt;指令（内部）内容&lt;/breadcrumb&gt;
</code></pre><hr>
<pre><code>2.js中的代码
myApp.directive(&apos;breadcrumb&apos;, [&apos;$parse&apos;, function($parse) {
    return {
        templateUrl: &apos;tmpls/breadcrumb.html&apos;,
        transclude:true
    }
}]);
</code></pre><hr>
<pre><code>3.tmpls/breadcrumb.html模板中的代码
&lt;ol&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot; ng-transclude&gt;模板1&lt;/a&gt;
        &lt;a href=&quot;#&quot;&gt;模板2&lt;/a&gt;
    &lt;/li&gt;
&lt;/ol&gt;
模板由两部分组成，一部分是含有ng-transclude指令的，一部分是不含有这个指令的
</code></pre><hr>
<h3 id="ng-if-跟-ng-show-hide-的区别"><a href="#ng-if-跟-ng-show-hide-的区别" class="headerlink" title="ng-if 跟 ng-show/hide 的区别"></a>ng-if 跟 ng-show/hide 的区别</h3><hr>
<pre><code>1. ng-if 在后面表达式为 true 的时候才创建这个 dom 节点。
ng-show 是初始时就创建了，用 display:block 和 display:none 来控制显示和不显示。
</code></pre><hr>
<pre><code>2. ng-if 会（隐式地）产生新作用域。
 ng-switch 、 ng-include 等会动态创建一块界面的也是如此。
 这样会导致，在 ng-if 中用基本变量绑定 ng-model ，
 并在外层 div 中把此 model 绑定给另一个显示区域，
 内层改变时，外层不会同步改变，因为此时已经是两个变量了。
</code></pre><hr>
<pre><code>&lt;p&gt;{{name}}&lt;/p&gt;
&lt;div ng-if=&quot;true&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
&lt;/div&gt;
ng-show 不存在此问题，因为它不自带一级作用域。
</code></pre><hr>
<pre><code>避免这类问题出现的办法是，始终将页面中的元素绑定到对象的属性（data.x）
而不是直接绑定到基本变量（x）上。
</code></pre><hr>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-25T08:57:38.000Z"><a href="/2016/09/25/Javascript面向对象编程/">2016-09-25</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/25/Javascript面向对象编程/">Javascript面向对象编程</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><pre><code>1. Javascript面向对象编程
    Javascript不是一种真正的面向对象编程（OOP）语言，
    语法中没有类的概念，却又是基于对象（object-based）的语言，
    你遇到的所有东西几乎都是对象。
    所以我们用构造函数的方法给一个函数加上属性和方法，成为一个对象。
</code></pre><hr>
<pre><code>2. 假定我们把Person看成一个对象，它有&quot;名字&quot;和&quot;颜色&quot;两个属性。
    var Person = {
        name : &apos;&apos;,
        age : &apos;&apos;
    } 
    现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象
            var Person1 = {}; // 创建一个空对象
            Person1.name = &quot;张三&quot;; // 按照原型对象的属性赋值
            Person1.age = &quot;33&quot;;
            var Person2 = {};
            Person2.name = &quot;李四&quot;;
            Person2.age = &quot;44&quot;;
    最简单的封装，把两个属性封装在一个对象里面。
    两个缺点，一是如果多生成几个实例，写起来就非常麻烦；
    二是实例与原型之间，没有任何办法，可以看出有什么联系
</code></pre><hr>
<pre><code>3. 原始模式的改进
    我们可以写一个函数，解决代码重复的问题。
        function Person(name,age) {
            return { 
                name:name,
                age:age
                }
            }
    然后生成实例对象，就等于是在调用函数：
    var Person1 = Person(&quot;张三&quot;,&quot;33&quot;);
    var Person2 = Person(&quot;李四&quot;,&quot;44&quot;);
    这种方法的问题依然是，Person1和Person2之间没有内在的联系，
    不能反映出它们是同一个原型对象的实例。
</code></pre><hr>
<pre><code>4. 构造函数模式
    为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数
    （Constructor）模式。
    所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。
    对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。
    比如，猫的原型对象现在可以这样写，
    function Person(name,age){
        this.name=name;
        this.age=age;
    }
    我们现在就可以生成实例对象了。
    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);
    var Person2 = new Person(&quot;李四&quot;,&quot;44&quot;);
    alert(Person1.name); // 张三
    alert(Person1.age); // 33这时Person1和Person2会自动含有一个
    constructor属性，指向它们的构造函数。
    alert(Person1.constructor == Person); //true
    alert(Person2.constructor == Person); //true
    Javascript还提供了一个instanceof运算符，验证原型对象
    与实例对象之间的关系。
    alert(Person1 instanceof Person); //true
    alert(Person2 instanceof Person); //true
    构造函数模式的问题
    构造函数方法很好用，但是存在一个浪费内存的问题。
    请看，我们现在为Person对象添加一个不变的属性type（种类），
    再添加一个方法eat（吃）。那么，原型对象Person就变成了下面这样：
    function Person(name,age){
        this.name = name;
        this.age = age;
        this.type = &quot;人&quot;;
        this.eat = function(){alert(&quot;吃饭&quot;);};
        }
    还是采用同样的方法，生成实例：
    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);
    var Person2 = new Person (&quot;李四&quot;,&quot;44&quot;);
    alert(Person1.type); // 人
    Person1.eat(); // 吃饭
    表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。
    对于每一个实例对象，type属性和eat()方法都是一模一样的内容，
    每一次生成一个实例，都必须为重复的内容，多占用一些内存。
    这样既不环保，也缺乏效率。
    alert(Person1.eat == Person2.eat); //false
    能不能让type属性和eat()方法在内存中只生成一次，
    然后所有实例都指向那个内存地址呢？回答是可以的。
</code></pre><hr>
<pre><code>5. Prototype模式
    Javascript规定，每一个构造函数都有一个prototype属性，
    指向另一个对象。
    这个对象的所有属性和方法，都会被构造函数的实例继承。
    这意味着，我们可以把那些不变的属性和方法，
    直接定义在prototype对象上。
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
    Person.prototype.type = &quot;人&quot;;
    Person.prototype.eat = function(){alert(&quot;吃饭&quot;)};
    然后，生成实例。
    var Person1 = new Person(&quot;张三&quot;,&quot;33&quot;);
    var Person2 = new Person(&quot;李四&quot;,&quot;44&quot;);
    alert(Person1.type); // 人
    Person1.eat(); // 吃饭
    这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，
    因此就提高了运行效率。
    alert(Person1.eat == Person2.eat); //true
</code></pre><hr>
<pre><code>6. Prototype模式的验证方法
为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，
    6.1 isPrototypeOf()
        这个方法用来判断，某个proptotype对象和某个实例之间的关系。
        alert(Person.prototype.isPrototypeOf(Person1)); //true
        alert(Person.prototype.isPrototypeOf(Person2)); //true
    6.2 hasOwnProperty()
        每个实例对象都有一个hasOwnProperty()方法，
        用来判断某一个属性到底是本地属性，
        还是继承自prototype对象的属性。
        alert(Person1.hasOwnProperty(&quot;name&quot;)); // true
        alert(Person1.hasOwnProperty(&quot;type&quot;)); // false
    6.3 in运算符
        in运算符可以用来判断，某个实例是否含有某个属性，
        不管是不是本地属性。
        alert(&quot;name&quot; in Person1); // true
        alert(&quot;type&quot; in Person1); // true
        in运算符还可以用来遍历某个对象的所有属性。
        for(var prop in Person1) {
         alert(&quot;Person1[&quot;+prop+&quot;]=&quot;+Person1[prop]); 
        }
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-20T08:56:48.000Z"><a href="/2016/09/20/Javascript闭包/">2016-09-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/20/Javascript闭包/">Javascript闭包</a></h1>
  

    </header>
    <div class="entry">
      
        <hr>
<h2 id="本文大部分出自阮一峰"><a href="#本文大部分出自阮一峰" class="headerlink" title="本文大部分出自阮一峰"></a>本文大部分出自阮一峰</h2><pre><code>1. 变量的作用域
    要理解闭包，首先必须理解Javascript特殊的变量作用域。
    变量的作用域无非就是两种：全局变量和局部变量。
    Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。
    var n=999;
    function f1(){
        alert(n);
    }
    f1(); // 999
    另一方面，在函数外部自然无法读取函数内的局部变量。
    function f1(){
        var n=999;
        }
    alert(n); // error
    这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。
    如果不用的话，你实际上声明了一个全局变量！
    function f1(){
        n=999;
        }
    f1();
    alert(n); // 999
</code></pre><hr>
<pre><code>2. 如何从外部读取局部变量？
    出于种种原因，我们有时候需要得到函数内的局部变量。
    但是，前面已经说过了，正常情况下，这是办不到的，
    只有通过变通方法才能实现。
    那就是在函数的内部，再定义一个函数。
    function f1(){
       var n=999;
       function f2(){
           alert(n); // 999
       }
    }
    在上面的代码中，函数f2就被包括在函数f1内部，
    这时f1内部的所有局部变量，对f2都是可见的。
    但是反过来就不行，f2内部的局部变量，对f1就是不可见的。
    这就是Javascript语言特有的&quot;链式作用域&quot;
    结构（chain scope），
    子对象会一级一级地向上寻找所有父对象的变量。
    所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
    既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，
    我们不就可以在f1外部读取它的内部变量了吗！
    function f1(){
        var n=999;
        function f2(){
            alert(n); 
        }
        return f2;
    }
    var result=f1();
    result(); // 999
</code></pre><hr>
<pre><code>3. 闭包的概念
    上一节代码中的f2函数，就是闭包。
    各种专业文献上的&quot;闭包&quot;（closure）定义非常抽象，很难看懂。
    我的理解是，闭包就是能够读取其他函数内部变量的函数。
    由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，
    因此可以把闭包简单理解成&quot;定义在一个函数内部的函数&quot;。
    所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁
</code></pre><hr>
<pre><code>4.闭包的用途
    闭包可以用在许多地方。它的最大用处有两个，
    一个是前面提到的可以读取函数内部的变量，
    另一个就是让这些变量的值始终保持在内存中。
    怎么来理解这句话呢？请看下面的代码。
    function f1(){
        var n=999;
        nAdd=function(){n+=1}
        function f2(){
            alert(n);
        }
        return f2;
    }
    var result=f1();
    result(); // 999
    nAdd();
    result(); // 1000在这段代码中，result实际上就是闭包f2函数。
    它一共运行了两次，第一次的值是999，第二次的值是1000。
    这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
    为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，
    这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，
    不会在调用结束后，被垃圾回收机制（garbage collection）回收。
    这段代码中另一个值得注意的地方，就是&quot;nAdd=function(){n+=1}&quot;这一行，
    首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。
    其次，nAdd的值是一个匿名函数（anonymous function），
    而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，
    可以在函数外部对函数内部的局部变量进行操作。
</code></pre><hr>
<pre><code>5. 使用闭包的注意点
    1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，
    所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
    解决方法是，在退出函数之前，将不使用的局部变量全部删除。
    2）闭包会在父函数外部，改变父函数内部变量的值。
    所以，如果你把父函数当作对象（object）使用，
    把闭包当作它的公用方法（Public Method），
    把内部变量当作它的私有属性（private value），这时一定要小心，
    不要随便改变父函数内部变量的值。
</code></pre><hr>
<pre><code>6. 思考题
    如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。
    代码片段一。
    var name = &quot;The Window&quot;;
    var object = {
        name : &quot;My Object&quot;,
        getNameFunc : function(){
            return function(){
                return this.name;
            };
        }
    };
    alert(object.getNameFunc()());
    弹出The Window

代码片段二。
    var name = &quot;The Window&quot;;
    var object = {
        name : &quot;My Object&quot;,
        getNameFunc : function(){
            var that = this;
            return function(){
                return that.name;
            };
        }
    };
    alert(object.getNameFunc()());
    很明显 弹出 My Object
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-10T09:02:24.000Z"><a href="/2016/09/10/CSS3/">2016-09-10</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/10/CSS3/">CSS3</a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>1. 文本垂直水平居中问题
    设置
    line-height
    text-alignt:center
</code></pre><hr>
<pre><code>2. 块状行内对齐
    vertical-align: middle
</code></pre><hr>
<pre><code>3.动画
https://songhuajian.github.io/SHJ/
</code></pre><hr>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.songhuajian.top">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2017/09/18/原型/">原型</a>
      </li>
    
      <li>
        <a href="/2016/11/21/Sublime-text-3-部分插件/">Sublime text 3 部分插件</a>
      </li>
    
      <li>
        <a href="/2016/10/15/Windows下的nodejs管理工具nvm/">Windows下的nodejs管理工具nvm</a>
      </li>
    
      <li>
        <a href="/2016/10/11/Angular路由/">Angular路由</a>
      </li>
    
      <li>
        <a href="/2016/10/05/AngularJS遇到的问题/">AngularJS遇到的问题</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2017 宋华健
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>